<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // let a = [1,2,3];
        // a.ezen = "ezen";

        // console.log(a);
        // // 배열임에도 오브젝트에 추가하는 형식과 똑같이 작동함
        // // 즉, 배열은 객체를 기반으로 한다는 것을 보여줌

        // let obj = {};
        // obj.ezen = "eee";

        // obj.oo = {start:0, end:2};
        // // 객체 안에 객체를 넣음

        // console.log(obj);
        // // 객체에 넣는 방식도 동일함 

        // Array.prototype.ezen = "ezenPrototype";
        // // 배열 자체(앞으로 생성될 모든 배열)의 prototype을 설정해준 것
        // // 마치 dna처럼 작동함
        // // 또 이렇게 작동을 한다는 것은 prototype 또한 객체라는 것을 보여줌
        // let b = [1, 2, 3];

        // console.log(b);
        
        // // -------------------------------------------------------------------

        // // 객체의 값을 조회/추가/삭제/변경 (CRUD)
        
        // // 객체 기본 생성 방식 (객체literal)
        // const obj1 = {
        //     name : '이순신', // key(속성) : value(값)
        //     job : '군인',
        //     age : 40,
        //     marriage : true,
        //     fight : function(){
        //         console.log("Fight");
        //     } // function도 넣을 수 있음
        //     // = new function(){}

        // };

        // console.log(obj1.name);
        // console.log(obj1['age']);

        // obj1.job = '죄인'; // value 변경
        // obj1['job'] = "평민"; // value 변경2

        // delete obj1.job; // key 삭제

        // obj1.fight(); // object속 함수 객체 실행

        // let a2 = obj1.fight; // a에 참조값을 넣음
        // a2(); // 참조값으로 가서 함수 호출 가능

        // let c = [[1, 2, 3] , [4, 5, 6], [7, 8, 9]];
        // // 배열에 배열의 참조값이 배열의 형태로 들어간 것
        
        // console.log(c[1][1]);

        // // ------------------------------------------------------------

        // // 제어문

        // var i = 10;

        // console.log(i);

        // // 지역변수화 하는 방법
        // (function(){

        // })();

        // (function(){
        //     // let a = 10; // block-level scope (블럭 내에서 유효성을 가짐)
        //     // 가장 가까운 블럭(={}) 까지만 유효성을 가짐
        //     var b = 20; // function-level scope (함수 내에서 유효성을 가짐)
        //     // 

        //     if (1)
        //     {
        //         let a = 10; 
        //     }
        //     console.log(a);
        // })();


        const f1 = function(){
            let a = 10;
            const f2 = function()
            {
                let a = 20;

                console.log(a);
            }
            f2();
        }
        f1();
        // 액자식 구조로 호출
        // a = 20 으로 호출

        const f3 = function(){
            let b = 10;
            const f4 = function()
            {
                // let b = 20;

                console.log(b);
            }
            f4();
        }
        f3();
        // 액자식 구조로 호출하다 값이 범위 내에 없으면
        // 위로 올라가서 뒤져서라도 호출 해옴
        // 자바스크립트만의 특징 (다른 언어는 없다고 에러가 남)
        // 그래서 b = 10으로 호출

        // ----------------------------------------

        // 1. switch문은 범위가 아니라 spot임

        const opt = 1;

        switch(opt) 
        {
            case 1 :
                console.log("1")
                break;
            case 2 :
                break;
            case 3 :
                break;
            dafault :
                break;
        }

        // 2. break가 없다면 지속적으로 진행

        let present = "";
        let opt2 = 2;
        // 옵션이 1이면 짜장면, 옵션이 2나 3이면 콜라, 옵션이 4면 햄버거, 옵션 선택 없을시 커피
        switch(opt2) 
        {
            case 1 :
            present = "짜장면"
                break;
            case 2 : // 다음 옵션과 겹치니까 break 없애도 콜라에서 걸리고 빠져나감
            case 3 :
            present = "콜라"
                break;
            case 4 :
            present = "햄버거"
                break;
            dafault :
            present = "커피"
                break;
        }

        console.log(present);
        // break를 없애면 안 멈추고 끝까지 와서 커피가 찍힘


        //-----------------------------------------------------------
        (function(){
            // 객체를 heap에 할당하는 방법

            // 1. 리터럴
            let product1 = {
                name : 'mouse',
                color : 'red',
                getColor : function(){
                    // this 는 this가 소속되어있는 객체를 칭함 (즉, product1)
                    return this.color;
                }
            };

            console.log(product1.getColor());

            // 2. new를 통해 생성 => 생성자(constructor)
            // : 객체를 초기화하는 함수

            let product2 = new Object();
            product2.name = 'keyboard';
            product2.color = 'black';

            console.log(product1);
            console.log(product2);

            // 리터럴을 통해 만들든 new를 통해 만들든 object는 똑같이 잘 생성됨

            let arr1 = [1, 2, 3, 4] // literal을 통해 배열 생성 (초기화)

            let arr2 = new Array(); // new를 통해 배열 생성(초기화가 아니라 빈 배열 생성)
            arr2[0] = 1; // 배열에 값 대입
            arr2[1] = 2;

            // new를 통해 초기화 하려면
            let arr3 = new Array(1, 2, 3, 4);

            // 10칸짜리 빈 배열을 만듦 (자리를 많이 잡아놓게 되니 속도면에서 유리해짐)
            let arr4 = new Array(10);

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);
            console.log(arr4);

            let d = 10;
            d = 20;
            // 자바스크립트는 기존 초기화된 변수에 값을 새로 할당하면 새로 메모리를 잡아서 만듦
            // 다른 언어들은 변수에 다시 값을 할당하는 식이지만 
            // (realocation = heap을 깨지 않는 방식) (대신 느림)
            // 자바스크립트는 그렇지 않음
            // 그래서 메모리를 많이 잡아먹음 (대신 속도는 훨씬 효율적임) 


            // 3. 함수를 통해 생성 (소스코드가 간결해지는 장점)

            // 빈 객체를 만들기 위한 함수임 (함수 첫글자를 주로 대문자로 함)
            // 빈 객체를 만들고 빈 객체에 참조값을 집어넣어서 생성시키는 방식
            const Product3 = function(name,color)
            {
                // this 는 this가 소속되어있는 객체를 칭함
                this.name = name;
                this.color = color;
                console.log(this);
            }
            new Product3();

            // 객체를 값을 넣어 따로따로 찍어내기
            const kb1 = new Product3("keyboard", "black");
            const kb2 = new Product3("keyboard", "white");
            console.log(kb1);
            console.log(kb1);
        })();

    </script>
    
</body>
</html>