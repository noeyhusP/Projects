<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    (function(){
    let data = [11, 22, 33, 44, 55];


    // obj가 data1, data2를 직접적으로 들고 있는 것이 아니라
    // obj내에 data1, data2의 참조값(각각의 시작정보)이 들어있고
    // data1, data2는 각각 stack과 heap에 데이터참조값과 데이터가 형성되는 것
    // 즉, obj내에서 stack에서 입출규칙과 네이밍 기능이 빠진 공간이 형성되는 것과 같음
    // 결론 : obj에 형성되는 모든 데이터는 객체로서 그 안의 정보는 heap에 따로
    // 시작정보(참조값)가 형성되고 그 참조값이 obj안에 쌓이는 것
    // 물론 obj도 stack과 heap에 각각 참조값과 함수가 형성된다
    // object에 들어가는 일반적인 데이터들을 attribute(=member variable) 라고 함
    // object에 들어가는 함수같은 기능들을 method(=member function) 라고 함
    let obj = {
        data1 : data,
        data2 : [10, 20, 30]

    };

    obj.data1[2]=77;

    console.log(obj.data1);
    console.log(obj.data2);
    console.log(obj.data2[1]);
    console.log(obj.data1[2]);
    // 객체 안에 key로 선언했지만 let data2 = [10,20,30] 으로 선언한 것과 같은 효과
    })();

    let data = [11, 22, 33, 44, 55];

    const f1 = function()
    {
        console.log("f1");

    }

    let obj = {
        data1 : data,
        data2 : [10,20,30],
        func : function()
        {
            console.log("f1");
        },
        // @@ 객체로 함수도 넣을 수 있음 (참조값이 들어간다는 건 뭐든 다 들어간단 소리)

        obb : {
            name : "aaa"
        }

    };

    obj.func();
    console.log(obj.obb.name); // @@ object 안에 object를 넣을 수도 있음
    // (object명.@@@) 식으로 호출


    </script>
</body>
</html>